#!/bin/bash

# Determine available dialog tool
if command -v whiptail &>/dev/null; then
    DIALOG_TOOL="whiptail"
elif command -v dialog &>/dev/null; then
    DIALOG_TOOL="dialog"
else
    echo "Error: whiptail or dialog is required but not installed."
    exit 1
fi

# Define common variables
# Array of executables to install
SCRIPT_NAMES=("jirasik" "jira-api" "jira-cli")

# Define installation directories for each scope
INSTALL_BIN_SYSTEM="/usr/local/bin"
INSTALL_BIN_USER="$HOME/.local/bin"
INSTALL_DIR_SYSTEM="/opt/jirasik"
INSTALL_DIR_USER="$HOME/.local/share/jirasik"

# Function to prompt using the available dialog tool
prompt_menu() {
    local title="$1"
    local prompt="$2"
    local height="$3"
    local width="$4"
    local menu_height="$5"
    shift 5
    local options=("$@")
    if [[ "$DIALOG_TOOL" == "whiptail" ]]; then
        whiptail --title "$title" --menu "$prompt" "$height" "$width" "$menu_height" "${options[@]}" 3>&1 1>&2 2>&3
    else
        dialog --title "$title" --menu "$prompt" "$height" "$width" "$menu_height" "${options[@]}" 3>&1 1>&2 2>&3
    fi
}

# Function to set installation paths based on selected type
set_install_paths() {
    local install_type="$1"
    if [[ "$install_type" == "1" ]]; then
        INSTALL_BIN="$INSTALL_BIN_USER"
        INSTALL_DIR="$INSTALL_DIR_USER"
    elif [[ "$install_type" == "2" ]]; then
        INSTALL_BIN="$INSTALL_BIN_SYSTEM"
        INSTALL_DIR="$INSTALL_DIR_SYSTEM"
        # Require sudo for system-wide
        if [[ $EUID -ne 0 ]]; then
            echo "System-wide installation requires sudo."
            exit 1
        fi
    else
        echo "Installation cancelled."
        exit 1
    fi
}

# Function to create symlinks for all executables
create_symlinks() {
    for script in "${SCRIPT_NAMES[@]}"; do
        TARGET="$1/$script"
        if [[ ! -f "$TARGET" ]]; then
            echo "Warning: '$script' not found, skipping."
            continue
        fi
        # Ensure the executable is executable
        chmod +x "$TARGET"
        ln -sf "$TARGET" "$INSTALL_BIN/$script"
        echo "Symlink created: $INSTALL_BIN/$script -> $TARGET"
    done
}

# Function to install in symlink mode
install_symlink_mode() {
    # Link all executables from the current folder.
    create_symlinks "$PWD"
}

# Function to install in standalone mode
install_standalone_mode() {
    mkdir -p "$INSTALL_DIR"
    # Copy all files (including hidden ones) from current folder into INSTALL_DIR.
    if command -v rsync &>/dev/null; then
        rsync -a --delete "$PWD"/ "$INSTALL_DIR"/
    else
        cp -r "$PWD"/. "$INSTALL_DIR"
    fi

    # Create a marker file to denote a standalone install.
    touch "$INSTALL_DIR/.jirasik_installed"

    # Create symlinks for all executables
    create_symlinks "$INSTALL_DIR"

    echo "Standalone installation complete:"
    echo "  Folder installed to: $INSTALL_DIR"
    echo "  Executables available in: $INSTALL_BIN"
}

# Function for PATH modification for user installation
update_path_if_needed() {
    if [[ "$INSTALL_BIN" == "$INSTALL_BIN_USER" && ":$PATH:" != *":$INSTALL_BIN:"* ]]; then
        SHELL_RC=""
        if [[ -n "$ZSH_VERSION" ]]; then
            SHELL_RC="$HOME/.zshrc"
        elif [[ -n "$BASH_VERSION" ]]; then
            SHELL_RC="$HOME/.bashrc"
            [[ -f "$HOME/.bash_profile" ]] && SHELL_RC="$HOME/.bash_profile"
        else
            SHELL_RC="$HOME/.profile"
        fi
        echo "export PATH=\"$INSTALL_BIN:\$PATH\"" >>"$SHELL_RC"
        echo "Added $INSTALL_BIN to PATH in $SHELL_RC. Please restart your terminal or run: source $SHELL_RC"
    fi
}

# Function to uninstall executables
uninstall_executables() {
    # Remove the symlinks from the bin directory
    for script in "${SCRIPT_NAMES[@]}"; do
        if [[ -L "$INSTALL_BIN/$script" ]]; then
            rm -f "$INSTALL_BIN/$script"
            echo "Removed symlink: $INSTALL_BIN/$script"
        else
            echo "No symlink found at $INSTALL_BIN/$script"
        fi
    done

    # If the installation directory contains the marker file, remove it.
    if [[ -f "$INSTALL_DIR/.jirasik_installed" ]]; then
        rm -rf "$INSTALL_DIR"
        echo "Removed standalone installation directory: $INSTALL_DIR"
    else
        echo "No standalone installation found in $INSTALL_DIR (symlink installation remains intact)."
    fi
}

# Main execution flow
main() {
    # Prompt for main action
    ACTION=$(prompt_menu "Jirasik Installer" "Choose an option:" 15 60 2 \
        "1" "Install Jirasik Tools" \
        "2" "Uninstall Jirasik Tools")

    if [[ "$ACTION" == "1" ]]; then
        # Installation process
        INSTALL_TYPE=$(prompt_menu "Installation Type" "Where do you want to install?" 15 60 2 \
            "1" "User-level (Installs in $INSTALL_BIN_USER)" \
            "2" "System-wide (Requires sudo; Installs in $INSTALL_BIN_SYSTEM)")

        set_install_paths "$INSTALL_TYPE"
        mkdir -p "$INSTALL_BIN"

        # Prompt for installation method
        METHOD=$(prompt_menu "Installation Method" "Choose installation method:" 15 60 2 \
            "1" "Symlink mode (link executables from current folder)" \
            "2" "Standalone mode (copy folder to install dir and link executables)")

        if [[ "$METHOD" == "1" ]]; then
            install_symlink_mode
        elif [[ "$METHOD" == "2" ]]; then
            install_standalone_mode
        else
            echo "Installation cancelled."
            exit 1
        fi

        update_path_if_needed
        echo "Installation complete! You can now run '${SCRIPT_NAMES[*]}' from anywhere."

    elif [[ "$ACTION" == "2" ]]; then
        # Uninstallation process
        UNINSTALL_TYPE=$(prompt_menu "Uninstall Jirasik" "Which installation do you want to remove?" 15 60 2 \
            "1" "User-level ($INSTALL_BIN_USER)" \
            "2" "System-wide ($INSTALL_BIN_SYSTEM) [Requires sudo]")

        set_install_paths "$UNINSTALL_TYPE"
        uninstall_executables
        echo "Uninstallation complete!"

    else
        echo "No valid action selected. Exiting."
        exit 1
    fi
}

# Run the main function
main
